"""
Comprehensive guardrail effectiveness tests for behavioral guardrails.

Uses adversarial and realistic AI-generated style inputs. TaskOutput mocks via conftest.
"""

from __future__ import annotations

from typing import Any

import pytest

from ai_team.guardrails.behavioral import (
    GuardrailResult,
    make_reasoning_guardrail,
    make_role_adherence_guardrail,
    make_scope_control_guardrail,
    output_format_guardrail,
    reasoning_guardrail,
    role_adherence_guardrail,
    scope_control_guardrail,
)


# -----------------------------------------------------------------------------
# Role adherence — adversarial
# -----------------------------------------------------------------------------


def test_frontend_developer_output_with_sql_delete_fails(task_output_factory: Any) -> None:
    """Frontend developer output containing SQL DELETE statements should fail."""
    # Realistic snippet that might be generated by a confused frontend agent
    raw = (
        "I've added the delete button and wired it to the API. "
        "On the backend you can run: DELETE FROM users WHERE id = ?; "
        "The React component calls fetch('/api/users/' + id, { method: 'DELETE' })."
    )
    result = role_adherence_guardrail(raw, "frontend_developer")
    assert result.status == "fail"
    assert "frontend" in result.message.lower() or "database" in result.message.lower()
    assert result.details and "violations" in result.details


def test_architect_output_with_data_mutations_fails(task_output_factory: Any) -> None:
    """Architect output containing raw data mutations should fail."""
    raw = (
        "The data layer will use a repository pattern. Example implementation: "
        "INSERT INTO audit_log (user_id, action) VALUES (?, ?); "
        "UPDATE settings SET last_seen = NOW() WHERE user_id = ?; "
        "We should avoid DELETE FROM in hot paths."
    )
    result = role_adherence_guardrail(raw, "architect")
    assert result.status == "fail"
    assert result.details and "violations" in result.details


def test_manager_output_with_code_implementation_fails(task_output_factory: Any) -> None:
    """Manager output containing code implementation should fail."""
    raw = (
        "I've assigned the task to the backend lead. Here's a quick reference they can use:\n"
        "import json\n"
        "def get_status():\n"
        "    return {'phase': 'development'}\n"
        "The team will complete this by Friday."
    )
    result = role_adherence_guardrail(raw, "manager")
    assert result.status == "fail"
    assert "manager" in result.message.lower() or "implementation" in result.message.lower() or "coordinate" in result.message.lower()


def test_valid_role_appropriate_output_passes(task_output_factory: Any) -> None:
    """Valid role-appropriate output should pass."""
    # Backend-only code, no frontend
    raw = (
        "from fastapi import APIRouter, Depends\n"
        "router = APIRouter()\n"
        "@router.get('/health')\n"
        "def health():\n"
        "    return {'status': 'ok'}\n"
    )
    result = role_adherence_guardrail(raw, "backend_developer")
    assert result.status == "pass"
    # Frontend-only
    ui = (
        "const LoginForm = () => {\n"
        "  const [email, setEmail] = useState('');\n"
        "  return <form onSubmit={handleSubmit}>...</form>;\n"
        "};\n"
    )
    result2 = role_adherence_guardrail(ui, "frontend_developer")
    assert result2.status == "pass"


# -----------------------------------------------------------------------------
# Scope control — adversarial
# -----------------------------------------------------------------------------


def test_output_discussing_unrelated_features_fails(task_output_factory: Any) -> None:
    """Output discussing unrelated features (scope creep) should fail."""
    requirements = "Add a login button and validate email format on the signup form."
    raw = (
        "We've implemented the login button and email validation. Additionally we added "
        "OAuth with Google and GitHub, password reset flow, admin dashboard, dark mode toggle, "
        "and a recommendation engine for the homepage. The login button is in the header."
    )
    result = scope_control_guardrail(raw, requirements, min_relevance=0.5)
    assert result.status in ("fail", "warn")
    # Low relevance to narrow requirement set should fail
    off_topic = "The weather API returns JSON. Frogs are amphibians. Coffee is popular."
    result2 = scope_control_guardrail(off_topic, requirements, min_relevance=0.5)
    assert result2.status == "fail"


def test_output_within_defined_scope_passes(task_output_factory: Any) -> None:
    """Output within defined scope should pass."""
    requirements = "Implement user login and logout with session management and Redis."
    raw = (
        "Implemented user login and logout with session management using Redis. "
        "Sessions are stored with a TTL; logout clears the key. Login validates credentials."
    )
    result = scope_control_guardrail(raw, requirements)
    assert result.status == "pass"
    assert result.details and "relevance_ratio" in result.details


# -----------------------------------------------------------------------------
# Reasoning — adversarial
# -----------------------------------------------------------------------------


def test_short_output_with_no_reasoning_indicators_fails(task_output_factory: Any) -> None:
    """Short output with no reasoning indicators should fail."""
    raw = "Done. Use the new endpoint."
    result = reasoning_guardrail(raw)
    assert result.status == "fail"
    assert "reasoning" in result.message.lower() or "rationale" in result.message.lower() or "short" in result.message.lower()


def test_output_with_clear_rationale_statements_passes(task_output_factory: Any) -> None:
    """Output with clear rationale statements should pass."""
    raw = (
        "We chose to use Redis for sessions because it provides TTL and is already in our stack. "
        "The reason we validate email on the client and server is to improve UX and security. "
        "Therefore the implementation includes both checks."
    )
    result = reasoning_guardrail(raw)
    assert result.status == "pass"
    # Long enough even without keywords
    long_ok = "This is a sufficiently long response that describes the approach in detail. " * 3
    result2 = reasoning_guardrail(long_ok)
    assert result2.status == "pass"


# -----------------------------------------------------------------------------
# CrewAI callables and TaskOutput mock
# -----------------------------------------------------------------------------


def test_make_role_adherence_guardrail_with_mock_task_output(task_output_factory: Any) -> None:
    """CrewAI-style guardrail receives output; use .raw when passed TaskOutput-like object."""
    # Behavioral guardrails in our codebase take (task_output: str), so we pass str from .raw
    fn = make_role_adherence_guardrail("frontend_developer")
    bad = "DELETE FROM users WHERE 1=1;"
    assert fn(bad) is False
    good = "const [count, setCount] = useState(0);"
    assert fn(good) is True


def test_make_scope_control_guardrail_with_realistic_text(task_output_factory: Any) -> None:
    """Scope control bound to requirements works with realistic text."""
    fn = make_scope_control_guardrail("Implement GET /users and POST /users with validation.")
    assert fn("Implemented GET /users and POST /users with Pydantic validation.") is True
    assert fn("Implemented quantum encryption and blockchain auth.") is False


def test_make_reasoning_guardrail_short_vs_rationale(task_output_factory: Any) -> None:
    """Reasoning guardrail fails short non-reasoned output, passes with rationale."""
    fn = make_reasoning_guardrail()
    assert fn("Done.") is False
    assert fn("We decided to use JWT because it is stateless and scales well.") is True
