# Best practices by topic for KnowledgeBase.
# Keys: python, api, database, testing, devops, security

python:
  - Follow PEP 8 for style (line length 88â€“100, black/ruff).
  - Use type hints on all public function and method signatures.
  - Prefer pathlib.Path over os.path; use context managers for resources.
  - Structure projects: src layout, py.typed, explicit package roots.
  - Prefer dataclasses or Pydantic for structured data over ad-hoc dicts.
  - Use virtual environments (venv/poetry) and pin dependencies.
  - Prefer list/dict comprehensions and generator expressions where readable.
  - Use structlog or logging consistently; avoid print() in production.
  - Catch specific exceptions; never bare except.
  - Prefer dependency injection and explicit config over globals.

api:
  - REST: use nouns for resources, HTTP verbs for actions; plural collections.
  - Status codes: 200 OK, 201 Created, 204 No Content, 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found, 422 Unprocessable Entity, 500 Internal Server Error.
  - Pagination: support limit/offset or cursor-based; return total count or next_cursor in response.
  - Error responses: consistent JSON shape (code, message, details); avoid leaking stack traces.
  - Version APIs via URL path (/v1/...) or Accept header; deprecate gracefully.
  - Document with OpenAPI/Swagger; keep examples and schemas in sync.
  - Use idempotency keys for write operations where applicable.
  - Rate limit and return 429 with Retry-After when appropriate.

database:
  - Normalize to 3NF unless denormalization is justified for read performance.
  - Index columns used in WHERE, JOIN, ORDER BY; avoid over-indexing writes.
  - Use migrations (Alembic, Django migrations) for schema changes; never ad-hoc DDL.
  - Prefer parameterized queries; never concatenate user input into SQL.
  - Use connection pooling and timeouts; avoid long-running transactions.
  - Design for rollback: reversible migrations, backward-compatible changes.
  - Document constraints and indexes; name them explicitly.

testing:
  - Follow test pyramid: many unit, fewer integration, few e2e.
  - Use fixtures (pytest fixtures, factory_boy) for shared setup; keep tests isolated.
  - Mock external services and I/O in unit tests; use contracts or test doubles in integration.
  - Cover happy path, edge cases, and error paths; aim for meaningful coverage (e.g. 80%+).
  - Name tests descriptively (test_<unit>_<scenario>_<expected>); one logical assertion per test when practical.
  - Avoid hardcoded values; use constants or config for environment-specific data.
  - Use setup/teardown or fixtures for cleanup; avoid test interdependence.

devops:
  - Docker: use multi-stage builds; run as non-root; pin base image tags; .dockerignore to reduce context.
  - docker-compose: single responsibility per service; use env files for secrets; define healthchecks.
  - CI/CD: run lint and unit tests on every PR; gate merge on passing pipeline; deploy from main/tag.
  - 12-factor app: config in environment; stateless processes; log to stdout; disposability.
  - Use semantic versioning; tag releases; keep changelog.
  - Prefer declarative IaC (Terraform, CloudFormation, K8s manifests); review changes in PRs.

security:
  - OWASP Top 10: mitigate injection (parameterized queries, validated input), broken auth (strong auth, session handling), XSS (escape output, CSP), insecure deserialization, misconfiguration.
  - Validate and sanitize all input; use allowlists; reject invalid data early.
  - Use standard auth patterns (OAuth2, JWT with short expiry); never store plaintext passwords.
  - Prefer least privilege; avoid running as root; lock down file and network access.
  - Keep dependencies updated; run bandit/pip-audit; scan for known CVEs in CI.
